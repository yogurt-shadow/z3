solver init
solver done
make var
make var done
make ineq atom
make ineq atom done
make var
make var done
make ineq atom
make ineq atom done
make clause
make clause done
make ineq atom
make ineq atom done
make clause
make clause done
make ineq atom
make ineq atom done
make clause
make clause done
make var
make var done
make ineq atom
make ineq atom done
make clause
make clause done
make ineq atom
make ineq atom done
make clause
make clause done
make ineq atom
make ineq atom done
make clause
make clause done
make ineq atom
make ineq atom done
make clause
make clause done
start check...
register vars done
register atoms done
frontend propagate literal true
frontend propagate literal skoSQ3 > 0
frontend propagate literal skoSQ3 > 0
frontend propagate literal skoX > 0
frontend propagate literal skoX > 0
frontend propagate literal 10000000 pi - 31415927 < 0
frontend propagate literal 10000000 pi - 31415927 < 0
frontend propagate literal 5000000 pi - 15707963 > 0
frontend propagate literal 5000000 pi - 15707963 > 0
frontend propagate literal 5000000 pi - 10000000 skoX - 1 > 0
frontend propagate literal skoSQ3^2 - 3 = 0
frontend propagate literal skoSQ3^2 - 3 = 0
register clauses done
register nlsat structures done
atom size: 9
0
9
assign literal: true
[unit propagate]
assign literal done
1
9
2
9
3
9
assign literal: skoSQ3 > 0
[unit propagate]
assign literal done
4
9
assign literal: skoX > 0
[unit propagate]
assign literal done
5
9
assign literal: 10000000 pi - 31415927 < 0
[unit propagate]
assign literal done
6
9
assign literal: 5000000 pi - 15707963 > 0
[unit propagate]
assign literal done
7
9
8
9
assign literal: skoSQ3^2 - 3 = 0
[unit propagate]
assign literal done
build frontend assignment done
build frontend infeasible done
display clauses
true
skoX = 0 or skoSQ3 = 0
skoSQ3 > 0
skoX > 0
10000000 pi - 31415927 < 0
5000000 pi - 15707963 > 0
5000000 pi - 10000000 skoX - 1 > 0
skoSQ3^2 - 3 = 0
start solving...
Display Status
m_hk: 4294967295
stage: 0
level: 0
Display Assignment
b0 -> true
b3 skoSQ3 > 0 -> true
b4 skoX > 0 -> true
b5 10000000 pi - 31415927 < 0 -> true
b6 5000000 pi - 15707963 > 0 -> true
b8 skoSQ3^2 - 3 = 0 -> true
================== Display Trails ==================
[BVAR ASSIGNMENT]: true -> bool_var 0
[BVAR ASSIGNMENT]: skoSQ3 > 0
[BVAR ASSIGNMENT]: skoX > 0
[BVAR ASSIGNMENT]: 10000000 pi - 31415927 < 0
[BVAR ASSIGNMENT]: 5000000 pi - 15707963 > 0
[BVAR ASSIGNMENT]: skoSQ3^2 - 3 = 0
[UPDT_EQ] decision
[INFEASIBLE UPDT]: {}
[INFEASIBLE UPDT]: {}
[INFEASIBLE UPDT]: {}
================== Trails Done ==================
skoX -> {(-oo, p4, 0]}
skoSQ3 -> {(-oo, p3, -1.7320508075?], (-1.7320508075?, p8, 1.7320508075?), (1.7320508075?, p8, oo)}
pi -> {(-oo, p6, 3.1415926], [3.1415927, p5, oo)}
skoX -> unit clause: 3 
 -> unit learned: 
skoSQ3 -> unit clause: 2 7 
 -> unit learned: 
pi -> unit clause: 4 5 
 -> unit learned: 
skoX -> unit atom: 1 4 
skoSQ3 -> unit atom: 2 3 8 
pi -> unit atom: 5 6 
use arith assignment to check atom
use infeasible to propagate atom
assign literal: !(skoX = 0)
[lazy propagate]
assign literal done
assign literal: !(skoSQ3 = 0)
[lazy propagate]
assign literal done
unit propagate
new stage
conflict clause: skoX = 0 or skoSQ3 = 0
m_hk: 1 skoSQ3
resolve clause
process antecedent for literal: skoX = 0
same stage and same level, increase mark 1
process antecedent for literal: skoSQ3 = 0
case 2, push back lemma: skoSQ3 = 0
resolve clause done
14
top: 14
14
top: 14
14
top: 13
14
top: 12
show trail bool: skoSQ3 = 0
real propagate case, resolve lazy
enter explain
make literal
make literal done
exit explain
resolve clause
process antecedent for literal: !(skoSQ3^2 - 3 = 0)
case 2, push back lemma: !(skoSQ3^2 - 3 = 0)
resolve clause done
resolve lazy done
resolve lazy done
bump hybrid vars
unsat
