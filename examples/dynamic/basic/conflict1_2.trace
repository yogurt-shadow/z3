solver init
solver done
make var
make var done
make ineq atom
make ineq atom done
make clause
make clause done
make var
make var done
make ineq atom
make ineq atom done
make clause
make clause done
make var
make var done
make ineq atom
make ineq atom done
make ineq atom
make ineq atom done
make clause
make clause done
start check...
0 -> x
1 -> y
2 -> z
register vars done
register atoms done
frontend propagate literal true
frontend propagate literal !(y - 23 < 0)
frontend propagate literal !(y - 23 < 0)
frontend propagate literal !(z - 18 > 0)
frontend propagate literal !(z - 18 > 0)
register clauses done
register nlsat structures done
assign literal: true
[unit propagate]
bool var: 0 
curr hybrid var: 0
size: 0
assign literal done
assign literal: !(y - 23 < 0)
[unit propagate]
assign literal done
assign literal: !(z - 18 > 0)
[unit propagate]
assign literal done
build frontend assignment done
build frontend infeasible done
display clauses
true
!(y - 23 < 0)
!(z - 18 > 0)
- y + x + 10 > 0 or - z + x + 30 < 0

start solving...
Display Status
m_hk: 4294967295
stage: 0
level: 0
Display Assignment
b0 -> true
b1 y - 23 < 0 -> false
b2 z - 18 > 0 -> false
================== Display Trails ==================
[BVAR ASSIGNMENT]: true -> bool_var 0
[BVAR ASSIGNMENT]: y - 23 < 0
[BVAR ASSIGNMENT]: z - 18 > 0
[INFEASIBLE UPDT]: {}
[INFEASIBLE UPDT]: {}
================== Trails Done ==================
x -> {}
y -> {(-oo, ~p1, 23)}
z -> {(18, ~p2, oo)}
y -> unit clause: 1 
 -> unit learned: 
z -> unit clause: 2 
 -> unit learned: 
y -> unit atom: 1 
z -> unit atom: 2 
overall propagate
new turn in propagate
use infeasible to propagate atom
unit propagate
propagate unit clauses
propagate unit learned
propagate more clauses
propagate more learned
propagate unit clauses
propagate unit learned
propagate more clauses
propagate more learned
propagate unit clauses
propagate unit learned
propagate more clauses
propagate more learned
rp clauses
rp learned
consistent
decide
curr m_hk: 4294967295
pick branching var: 1 x
new stage
before witness
bool var: 0 
use arith assignment to check atom
assign literal: !(- y + x + 10 > 0)
[lazy propagate]
assign literal done
assign literal: !(- z + x + 30 < 0)
[lazy propagate]
assign literal done
check atom done
bool var: 0 arith var: 0 
curr hybrid var: 1
size: 1
- y + x + 10 > 0 or - z + x + 30 < 0
ano: 2
after witness
bool var: 0 arith var: 0 
Display Status
m_hk: 1
stage: 1
level: 0
Display Assignment
b0 -> true
b1 y - 23 < 0 -> false
b2 z - 18 > 0 -> false
b3 - y + x + 10 > 0 -> false
b4 - z + x + 30 < 0 -> false
var 0 x -> 0
================== Display Trails ==================
[BVAR ASSIGNMENT]: true -> bool_var 0
[BVAR ASSIGNMENT]: y - 23 < 0
[BVAR ASSIGNMENT]: z - 18 > 0
[INFEASIBLE UPDT]: {}
[INFEASIBLE UPDT]: {}
[NEW STAGE]
[BRANCH] old m_hk: 4294967295  new m_hk: 1
[ARITH ASSIGNMENT]: x -> 0
[BVAR ASSIGNMENT]: - y + x + 10 > 0
[BVAR ASSIGNMENT]: - z + x + 30 < 0
================== Trails Done ==================
x -> {}
y -> {(-oo, ~p1, 23)}
z -> {(18, ~p2, oo)}
y -> unit clause: 1 
 -> unit learned: 
z -> unit clause: 2 
 -> unit learned: 
y -> unit atom: 1 3 
z -> unit atom: 2 4 
overall propagate
new turn in propagate
use infeasible to propagate atom
unit propagate
propagate unit clauses
propagate unit learned
propagate more clauses
direct stage to conflict clause: 3
- y + x + 10 > 0 or - z + x + 30 < 0
new stage
before witness
bool var: 0 arith var: 0 
use arith assignment to check atom
check atom done
bool var: 0 arith var: 0 arith var: 1 
curr hybrid var: 2
size: 1
- y + x + 10 > 0 or - z + x + 30 < 0
ano: 3
not found
after witness
bool var: 0 arith var: 0 arith var: 1 
new stage
conflict clause: - y + x + 10 > 0 or - z + x + 30 < 0
m_hk: 3 z
Display Assignment
b0 -> true
b1 y - 23 < 0 -> false
b2 z - 18 > 0 -> false
b3 - y + x + 10 > 0 -> false
b4 - z + x + 30 < 0 -> false
var 0 x -> 0
var 1 y -> 24
resolve clause
process antecedent for literal: - y + x + 10 > 0
case 2, push back lemma: - y + x + 10 > 0
process antecedent for literal: - z + x + 30 < 0
same stage and same level, increase mark 1
resolve clause done
show trail bool: - z + x + 30 < 0
real propagate case, resolve lazy
make ineq atom
make ineq atom done
new valid clause in explain:
!(x + 12 > 0) or !(- z + x + 30 < 0) or z - 18 > 0
resolve clause
process antecedent for literal: !(x + 12 > 0)
case 1, push back lemma: !(x + 12 > 0)
process antecedent for literal: z - 18 > 0
same stage and same level, increase mark 1
resolve clause done
resolve lazy done
resolve lazy done
show trail bool: - y + x + 10 > 0
real propagate case, resolve lazy
make ineq atom
make ineq atom done
new valid clause in explain:
!(x - 13 < 0) or y - 23 < 0 or !(- y + x + 10 > 0)
resolve clause
process antecedent for literal: !(x - 13 < 0)
case 1, push back lemma: !(x - 13 < 0)
process antecedent for literal: y - 23 < 0
case 2, push back lemma: y - 23 < 0
resolve clause done
resolve lazy done
resolve lazy done
bump hybrid vars
show lemma:
- y + x + 10 > 0 or !(x + 12 > 0) or !(x - 13 < 0) or y - 23 < 0
new lemma: - y + x + 10 > 0 or !(x + 12 > 0) or !(x - 13 < 0) or y - 23 < 0
Display Status
m_hk: 2
stage: 2
level: 0
Display Assignment
b0 -> true
b1 y - 23 < 0 -> false
b2 z - 18 > 0 -> false
b3 - y + x + 10 > 0 -> false
b4 - z + x + 30 < 0 -> false
var 0 x -> 0
================== Display Trails ==================
[BVAR ASSIGNMENT]: true -> bool_var 0
[BVAR ASSIGNMENT]: y - 23 < 0
[BVAR ASSIGNMENT]: z - 18 > 0
[INFEASIBLE UPDT]: {}
[INFEASIBLE UPDT]: {}
[NEW STAGE]
[BRANCH] old m_hk: 4294967295  new m_hk: 1
[ARITH ASSIGNMENT]: x -> 0
[BVAR ASSIGNMENT]: - y + x + 10 > 0
[BVAR ASSIGNMENT]: - z + x + 30 < 0
[NEW STAGE]
[BRANCH] old m_hk: 1  new m_hk: 2
================== Trails Done ==================
x -> {}
y -> {(-oo, ~p1, 23)}
z -> {(18, ~p2, oo)}
y -> unit clause: 
 -> unit learned: 0 
z -> unit clause: 2 
 -> unit learned: 
y -> unit atom: 3 
z -> unit atom: 2 4 
conflict clause: - y + x + 10 > 0 or !(x + 12 > 0) or !(x - 13 < 0) or y - 23 < 0
m_hk: 2 y
Display Assignment
b0 -> true
b1 y - 23 < 0 -> false
b2 z - 18 > 0 -> false
b3 - y + x + 10 > 0 -> false
b4 - z + x + 30 < 0 -> false
var 0 x -> 0
resolve clause
process antecedent for literal: - y + x + 10 > 0
same stage and same level, increase mark 1
process antecedent for literal: !(x + 12 > 0)
case 1, push back lemma: !(x + 12 > 0)
process antecedent for literal: !(x - 13 < 0)
case 1, push back lemma: !(x - 13 < 0)
process antecedent for literal: y - 23 < 0
same stage and same level, increase mark 2
resolve clause done
show trail bool: - z + x + 30 < 0
show trail bool: - y + x + 10 > 0
real propagate case, resolve lazy
make ineq atom
make ineq atom done
new valid clause in explain:
!(x - 13 < 0) or y - 23 < 0 or !(- y + x + 10 > 0)
resolve clause
process antecedent for literal: !(x - 13 < 0)
process antecedent for literal: y - 23 < 0
resolve clause done
resolve lazy done
resolve lazy done
show trail bool: z - 18 > 0
unit propagate case, resolve clause
resolve clause
resolve clause done
resolve clause done
bump hybrid vars
show lemma:
!(x + 12 > 0) or !(x - 13 < 0)
new lemma: !(x + 12 > 0) or !(x - 13 < 0)
Display Status
m_hk: 1
stage: 1
level: 0
Display Assignment
b0 -> true
b1 y - 23 < 0 -> false
b2 z - 18 > 0 -> false
================== Display Trails ==================
[BVAR ASSIGNMENT]: true -> bool_var 0
[BVAR ASSIGNMENT]: y - 23 < 0
[BVAR ASSIGNMENT]: z - 18 > 0
[INFEASIBLE UPDT]: {}
[INFEASIBLE UPDT]: {}
[NEW STAGE]
[BRANCH] old m_hk: 4294967295  new m_hk: 1
================== Trails Done ==================
x -> {}
y -> {(-oo, ~p1, 23)}
z -> {(18, ~p2, oo)}
x -> unit clause: 
 -> unit learned: 1 
z -> unit clause: 2 
 -> unit learned: 
z -> unit atom: 2 
overall propagate
new turn in propagate
use infeasible to propagate atom
unit propagate
propagate unit clauses
propagate unit learned
propagate more clauses
propagate more learned
rp clauses
rp learned
use infeasible to propagate atom
consistent
decide
curr m_hk: 1
current m_hk is not assigned, choose value
before witness
bool var: 0 
use arith assignment to check atom
assign literal: !(- y + x + 10 > 0)
[lazy propagate]
assign literal done
check atom done
bool var: 0 arith var: 0 
curr hybrid var: 1
size: 0
after witness
bool var: 0 arith var: 0 
Display Status
m_hk: 1
stage: 1
level: 0
Display Assignment
b0 -> true
b1 y - 23 < 0 -> false
b2 z - 18 > 0 -> false
b3 - y + x + 10 > 0 -> false
var 0 x -> -13
================== Display Trails ==================
[BVAR ASSIGNMENT]: true -> bool_var 0
[BVAR ASSIGNMENT]: y - 23 < 0
[BVAR ASSIGNMENT]: z - 18 > 0
[INFEASIBLE UPDT]: {}
[INFEASIBLE UPDT]: {}
[NEW STAGE]
[BRANCH] old m_hk: 4294967295  new m_hk: 1
[INFEASIBLE UPDT]: {}
[ARITH ASSIGNMENT]: x -> -13
[BVAR ASSIGNMENT]: - y + x + 10 > 0
================== Trails Done ==================
x -> {(-12, ~p6, 13)}
y -> {(-oo, ~p1, 23)}
z -> {(18, ~p2, oo)}
y -> unit clause: 
 -> unit learned: 0 
z -> unit clause: 2 
 -> unit learned: 
y -> unit atom: 3 
z -> unit atom: 2 4 
overall propagate
new turn in propagate
use infeasible to propagate atom
unit propagate
propagate unit clauses
propagate unit learned
propagate more clauses
propagate more learned
rp clauses
rp learned
use infeasible to propagate atom
consistent
decide
curr m_hk: 1
pick branching var: 2 y
new stage
before witness
bool var: 0 arith var: 0 
use arith assignment to check atom
check atom done
bool var: 0 arith var: 0 arith var: 1 
curr hybrid var: 2
size: 1
- y + x + 10 > 0 or - z + x + 30 < 0
ano: 3
not found
after witness
bool var: 0 arith var: 0 arith var: 1 
Display Status
m_hk: 2
stage: 2
level: 0
Display Assignment
b0 -> true
b1 y - 23 < 0 -> false
b2 z - 18 > 0 -> false
b3 - y + x + 10 > 0 -> false
var 0 x -> -13
var 1 y -> 24
================== Display Trails ==================
[BVAR ASSIGNMENT]: true -> bool_var 0
[BVAR ASSIGNMENT]: y - 23 < 0
[BVAR ASSIGNMENT]: z - 18 > 0
[INFEASIBLE UPDT]: {}
[INFEASIBLE UPDT]: {}
[NEW STAGE]
[BRANCH] old m_hk: 4294967295  new m_hk: 1
[INFEASIBLE UPDT]: {}
[ARITH ASSIGNMENT]: x -> -13
[BVAR ASSIGNMENT]: - y + x + 10 > 0
[INFEASIBLE UPDT]: {(-oo, ~p1, 23)}
[NEW STAGE]
[BRANCH] old m_hk: 1  new m_hk: 2
[ARITH ASSIGNMENT]: y -> 24
================== Trails Done ==================
x -> {(-12, ~p6, 13)}
y -> {(-oo, ~p1, 23)}
z -> {(18, ~p2, oo)}
z -> unit clause: 2 3 
 -> unit learned: 
z -> unit atom: 2 4 
overall propagate
var 2empty
new turn in propagate
use infeasible to propagate atom
unit propagate
rp clauses
use infeasible to propagate atom
assign literal: - z + x + 30 < 0
[lazy propagate]
assign literal done
rp learned
new turn in propagate
use infeasible to propagate atom
unit propagate
propagate unit clauses
propagate unit learned
propagate more clauses
propagate more learned
rp clauses
rp learned
consistent
decide
curr m_hk: 2
pick branching var: 3 z
new stage
before witness
bool var: 0 arith var: 0 arith var: 1 
use arith assignment to check atom
check atom done
bool var: 0 arith var: 0 arith var: 1 arith var: 2 
curr hybrid var: 3
size: 1
- y + x + 10 > 0 or - z + x + 30 < 0
ano: 2
after witness
bool var: 0 arith var: 0 arith var: 1 arith var: 2 
Display Status
m_hk: 3
stage: 3
level: 0
Display Assignment
b0 -> true
b1 y - 23 < 0 -> false
b2 z - 18 > 0 -> false
b3 - y + x + 10 > 0 -> false
b4 - z + x + 30 < 0 -> true
var 0 x -> -13
var 1 y -> 24
var 2 z -> 17.5
================== Display Trails ==================
[BVAR ASSIGNMENT]: true -> bool_var 0
[BVAR ASSIGNMENT]: y - 23 < 0
[BVAR ASSIGNMENT]: z - 18 > 0
[INFEASIBLE UPDT]: {}
[INFEASIBLE UPDT]: {}
[NEW STAGE]
[BRANCH] old m_hk: 4294967295  new m_hk: 1
[INFEASIBLE UPDT]: {}
[ARITH ASSIGNMENT]: x -> -13
[BVAR ASSIGNMENT]: - y + x + 10 > 0
[INFEASIBLE UPDT]: {(-oo, ~p1, 23)}
[NEW STAGE]
[BRANCH] old m_hk: 1  new m_hk: 2
[ARITH ASSIGNMENT]: y -> 24
[INFEASIBLE UPDT]: {(18, ~p2, oo)}
[BVAR ASSIGNMENT]: - z + x + 30 < 0
[NEW STAGE]
[BRANCH] old m_hk: 2  new m_hk: 3
[ARITH ASSIGNMENT]: z -> 17.5
================== Trails Done ==================
x -> {(-12, ~p6, 13)}
y -> {(-oo, ~p1, 23)}
z -> {(-oo, p4, 17], (18, ~p2, oo)}
overall propagate
consistent
decide
curr m_hk: 3
pick branching var: 4294967295
sat
